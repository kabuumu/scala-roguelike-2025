package game

import game.entity.*
import game.entity.EntityType.*
import game.system.*
import game.system.event.GameSystemEvent.GameSystemEvent
import map.Dungeon
import util.LineOfSight
import game.entity.Hitbox.*

import scala.annotation.tailrec

case class GameState(playerEntityId: String,
                     entities: Seq[Entity],
                     messages: Seq[String] = Nil,
                     worldMap: map.WorldMap,
                     dungeonFloor: Int = 1) {
  
  // Index for O(1) entity lookup by ID
  private lazy val entityIndex: Map[String, Entity] = entities.map(e => e.id -> e).toMap
  
  val playerEntity: Entity = entityIndex(playerEntityId)

  def getEntity(entityId: String): Option[Entity] = {
    entityIndex.get(entityId)
  }

  // Phased system execution ordering for explicit lifecycle management  
  // This addresses ordering inconsistencies and enables event scoping
  // Updated to include new systems from main branch
  private val phases: Seq[Seq[GameSystem]] = Seq(
    // Phase 1: Input processing and early systems
    Seq(
      DeathHandlerSystem,
      StairsSpawnSystem,
      ExperienceSystem,
      EnemyAISystem,
      MovementSystem,
      VelocitySystem,
      WaveSystem,
      ItemUseSystem, // New unified item system
      HealingSystem, // Handles healing events
      EquipInputSystem,
      DescendStairsSystem,
      TradeSystem // Handles buy/sell transactions
    ),
    // Phase 2: Creation and spawning  
    Seq(
      MessageSystem, // Handles message events
      SpawnEntitySystem, // Enhanced to handle collision-checked spawning
      SpawnProjectileSystem,
      WaitSystem,
      OpenDoorSystem
    ),
    // Phase 3: Combat and collision processing
    // InventorySystem moved here to handle CollisionEvent before it's dropped
    // CollisionEvent events are dropped after this phase
    Seq(
      CollisionCheckSystem,
      AttackSystem,
      RangeCheckSystem,
      CollisionHandlerSystem,
      DamageSystem,
      InventorySystem // Moved from Phase 4 to handle CollisionEvent for pickup
    ),
    // Phase 4: Equipment and progression
    Seq(
      EquipmentSystem,
      InitiativeSystem,
      LevelUpSystem,
      SightMemorySystem,
      EventMemorySystem
    )
  )

  // Maintain backward compatibility by exposing flattened systems
  val systems: Seq[GameSystem] = phases.flatten

  def updateWithSystems(initialEvents: Seq[GameSystemEvent]): GameState = {
    val (_, finalState) = phases.zipWithIndex.foldLeft((initialEvents, this)) {
      case ((incomingEvents, stateAtPhaseStart), (systemsInPhase, phaseIndex)) =>
        // Execute all systems in this phase, accumulating events generated within the phase
        val (stateAfterPhase, phaseEmittedEvents) = systemsInPhase.foldLeft((stateAtPhaseStart, Vector.empty[GameSystemEvent])) {
          case ((currentState, accumulatedPhaseEvents), system) =>
            // Each system sees incoming events plus events generated by previous systems in this phase
            val visibleEvents = incomingEvents ++ accumulatedPhaseEvents
            val (newState, newEvents) = system.update(currentState, visibleEvents)
            (newState, accumulatedPhaseEvents ++ newEvents)
        }

        // Combine incoming events with events generated during this phase
        val allPhaseEvents = incomingEvents ++ phaseEmittedEvents

        // Apply event scoping rules based on phase
        val carryOverEvents: Seq[GameSystemEvent] = phaseIndex match {
          case 2 => // After Phase 3 (collision phase): drop CollisionEvent only
            allPhaseEvents.collect { case e if !e.isInstanceOf[game.system.event.GameSystemEvent.CollisionEvent] => e }
          case _ => // All other phases: carry over all events (including InputEvent)
            allPhaseEvents
        }

        (carryOverEvents, stateAfterPhase)
    }
    finalState
  }

  def updateEntity(entityId: String, newEntity: Entity): GameState =
    copy(entities = entities.updated(entities.indexWhere(_.id == entityId), newEntity))

  /**
   * Update an entity by ID. Returns unchanged GameState if entity not found.
   * Note: Silent failure is intentional to avoid crashes. Callers should ensure
   * entity exists before calling if failure needs to be detected.
   */
  def updateEntity(entityId: String, update: Entity => Entity): GameState = {
    val index = entities.indexWhere(_.id == entityId)
    if (index >= 0) {
      copy(entities = entities.updated(index, update(entities(index))))
    } else {
      this
    }
  }

  def getActor(point: Point): Option[Entity] = {
    entities.find(entity => entity.exists[Movement](_.position == point) && (entity.exists[EntityTypeComponent](entityType => entityType.entityType == EntityType.Enemy || entityType.entityType == EntityType.Player)))
  }

  def add(entity: Entity): GameState = {
    copy(entities = entities :+ entity)
  }

  def remove(entityId: String): GameState = {
    copy(entities = entities.filterNot(_.id == entityId))
  }

  //TODO - remove magic number
  def getVisiblePointsFor(entity: Entity): Set[Point] = for {
    entityPosition <- entity.hitbox
    lineOfSight <- LineOfSight.getVisiblePoints(entityPosition, lineOfSightBlockingPoints, 10)
  } yield lineOfSight

  def addMessage(message: String): GameState = {
    copy(messages = message +: messages)
  }

  lazy val lineOfSightBlockingPoints: Set[Point] = worldMap.walls ++ worldMap.rocks ++
    entities
      .filter(_.entityType.isInstanceOf[LockedDoor])
      .flatMap(_.get[Movement].map(_.position))
      .toSet

  lazy val movementBlockingPoints: Set[Point] = worldMap.walls ++ worldMap.water ++ worldMap.rocks ++
    entities
      .filter(entity => entity.get[EntityTypeComponent].exists(c => 
        c.entityType == EntityType.Enemy || c.entityType == EntityType.Player || c.entityType.isInstanceOf[LockedDoor]
      ))
      .flatMap { entity =>
        // Get all points occupied by multi-tile entities (like the boss)
        val basePosition = entity.get[Movement].map(_.position).getOrElse(Point(0, 0))
        entity.get[game.entity.Hitbox] match {
          case Some(hitbox) =>
            // Multi-tile entity: include all hitbox points
            hitbox.points.map(hitboxPoint => Point(basePosition.x + hitboxPoint.x, basePosition.y + hitboxPoint.y))
          case None =>
            // Single-tile entity: just the base position
            Set(basePosition)
        }
      }
      .toSet
  
  lazy val drawableChanges: Seq[Set[(Point, Sprite)]] = {
    import game.entity.Drawable.*
    entities.map(_.sprites)
  }
}
