<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/scala/indigoengine/view/Elements.scala">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/scala/indigoengine/view/Elements.scala" />
              <option name="originalContent" value="package indigoengine.view&#10;&#10;import game.entity.{Entity, Equipment}&#10;import game.entity.Equipment.*&#10;import game.status.StatusEffect&#10;import generated.{Assets, PixelFont, PixelFontSmall}&#10;import indigo.*&#10;import indigo.Batch.toBatch&#10;import indigoengine.SpriteExtension.*&#10;import ui.UIConfig.*&#10;import ui.{GameController, UIState}&#10;&#10;object Elements {&#10;  def text(text: String, x: Int, y: Int): SceneNode = Text(&#10;    text,&#10;    x,&#10;    y,&#10;    PixelFont.fontKey,&#10;    Assets.assets.generated.PixelFontMaterial&#10;  )&#10;&#10;  def wrapText(text: String, maxLineLength: Int): Seq[String] = {&#10;    text.split(&quot;\\s+&quot;).foldLeft(Seq(&quot;&quot;)) { (lines, word) =&gt;&#10;      val currentLine = lines.last&#10;      if (currentLine.isEmpty) lines.init :+ word&#10;      else if ((currentLine.length + 1 + word.length) &lt;= maxLineLength)&#10;        lines.init :+ (currentLine + &quot; &quot; + word)&#10;      else&#10;        lines :+ word&#10;    }&#10;  }&#10;&#10;  def healthBar(model: GameController): Batch[SceneNode] = {&#10;    import game.entity.Health.*&#10;&#10;    val currentHealth = model.gameState.playerEntity.currentHealth&#10;    val maxHealth = model.gameState.playerEntity.maxHealth&#10;&#10;    val barWidth = spriteScale * 6 // Total width of the health bar&#10;    val barHeight = (spriteScale / 4) * 3 // Height of the health bar&#10;    val xOffset = uiXOffset // X position of the bar&#10;    val yOffset = uiYOffset // Y position of the bar&#10;&#10;    val filledWidth = (currentHealth * barWidth) / maxHealth&#10;&#10;    BlockBar.attributeBar(&#10;      Rectangle(Point(xOffset, yOffset), Size(barWidth, barHeight)),&#10;      filledWidth,&#10;      RGBA.Green,&#10;      RGBA.Crimson,&#10;    ) :+ text(s&quot;$currentHealth/$maxHealth&quot;, xOffset + barWidth + defaultBorderSize, yOffset)&#10;  }&#10;  &#10;  def experienceBar(model: GameController): Batch[SceneNode] = {&#10;    import game.entity.Experience.*&#10;&#10;    val player = model.gameState.playerEntity&#10;    &#10;    val currentExp = player.experience&#10;    val nextLevelExp = player.nextLevelExperience&#10;&#10;    val drawableCurrentExperience = currentExp - player.previousLevelExperience&#10;    val drawableNextLevelExperience = nextLevelExp - player.previousLevelExperience&#10;&#10;    // Calculate the width of the filled portion of the experience bar&#10;&#10;    val barWidth = spriteScale * 6 // Total width of the experience bar&#10;    val barHeight = spriteScale / 2 // Height of the experience bar&#10;    val xOffset = uiXOffset // X position of the bar&#10;    val yOffset = uiYOffset + spriteScale // Y position of the bar&#10;&#10;    val filledWidth: Int = if (player.canLevelUp) barWidth &#10;    else (drawableCurrentExperience * barWidth) / drawableNextLevelExperience&#10;&#10;    BlockBar.attributeBar(&#10;      Rectangle(Point(xOffset, yOffset), Size(barWidth, barHeight)),&#10;      filledWidth,&#10;      RGBA.Orange,&#10;      RGBA.SlateGray,&#10;    ) ++ (if(player.canLevelUp)&#10;      Some(text(&quot;Press 'L' to level up!&quot;, xOffset + barWidth + defaultBorderSize, yOffset - defaultBorderSize))&#10;    else None).toSeq.toBatch&#10;  }&#10;&#10;  def usableItems(model: GameController, spriteSheet: Graphic[?]): Batch[SceneNode] = {&#10;    import game.entity.Inventory.*&#10;    import game.entity.{PotionItem, ScrollItem, BowItem}&#10;    import data.Sprites&#10;    &#10;    val player = model.gameState.playerEntity&#10;    val usableItems = player.usableItems(model.gameState)&#10;    if (usableItems.isEmpty) {&#10;      Batch.empty&#10;    } else {&#10;      val startX = uiXOffset&#10;      val startY = uiYOffset + (spriteScale * 2) + defaultBorderSize // Position below experience bar&#10;      val itemSize = spriteScale&#10;      val itemSpacing = itemSize + (defaultBorderSize / 2)&#10;      &#10;      // Display each usable item as an icon (no title needed)&#10;      // Display each usable item as an icon (no title needed)&#10;      val itemDisplays = usableItems.zipWithIndex.map { case (item, index) =&gt;&#10;    }&#10;  }&#10;  &#10;        // Determine sprite based on item type&#10;        val sprite = if (item.has[PotionItem]) Sprites.potionSprite&#10;                    else if (item.has[ScrollItem]) Sprites.scrollSprite&#10;                    else if (item.has[BowItem]) Sprites.bowSprite&#10;                    else Sprites.defaultItemSprite&#10;    // TODO: Reimplement keys display for new component system  &#10;        spriteSheet.fromSprite(sprite).moveTo(itemX, itemY)&#10;    import game.entity.Equipment.*&#10;&#10;    val player = model.gameState.playerEntity&#10;    val equipment = player.equipment&#10;    &#10;    // Position paperdoll on the right side of the screen with more space&#10;    val paperdollWidth = spriteScale * 4&#10;    val paperdollHeight = spriteScale * 5&#10;    val paperdollX = canvasWidth - paperdollWidth - defaultBorderSize&#10;    val paperdollY = uiYOffset&#10;    &#10;    // Create background for paperdoll&#10;    val background = BlockBar.getBlockBar(&#10;      Rectangle(Point(paperdollX - defaultBorderSize, paperdollY - defaultBorderSize), &#10;                Size(paperdollWidth + (defaultBorderSize * 2), paperdollHeight + (defaultBorderSize * 2))),&#10;      RGBA.SlateGray.withAlpha(0.3f)&#10;    )&#10;    &#10;    // Title&#10;    val title = text(&quot;Equipment&quot;, paperdollX, paperdollY - (defaultBorderSize * 3))&#10;    &#10;    // Helmet slot with better spacing&#10;    val helmetY = paperdollY + spriteScale&#10;    val helmetSlotX = paperdollX + spriteScale * 3&#10;    val helmetSlot = BlockBar.getBlockBar(&#10;      Rectangle(Point(helmetSlotX, helmetY), Size(spriteScale, spriteScale)),&#10;      RGBA.SlateGray.withAlpha(0.5f)&#10;    )&#10;    val helmetLabel = text(&quot;Helmet:&quot;, paperdollX + defaultBorderSize, helmetY + (spriteScale / 4))&#10;    &#10;    val helmetItem = equipment.helmet.map { helmet =&gt;&#10;      val sprite = helmet.itemName match {&#10;        case &quot;Leather Helmet&quot; =&gt; data.Sprites.leatherHelmetSprite&#10;        case &quot;Iron Helmet&quot; =&gt; data.Sprites.ironHelmetSprite&#10;        case _ =&gt; data.Sprites.defaultItemSprite&#10;      }&#10;      spriteSheet.fromSprite(sprite).moveTo(helmetSlotX, helmetY)&#10;    }.toSeq&#10;    &#10;    // Armor slot with better spacing  &#10;    val armorY = paperdollY + (spriteScale * 2) + defaultBorderSize&#10;    val armorSlotX = paperdollX + spriteScale * 3&#10;    val armorSlot = BlockBar.getBlockBar(&#10;      Rectangle(Point(armorSlotX, armorY), Size(spriteScale, spriteScale)),&#10;      RGBA.SlateGray.withAlpha(0.5f)&#10;    )&#10;    val armorLabel = text(&quot;Armor:&quot;, paperdollX + defaultBorderSize, armorY + (spriteScale / 4))&#10;    &#10;    val armorItem = equipment.armor.map { armor =&gt;&#10;      val sprite = armor.itemName match {&#10;        case &quot;Chainmail Armor&quot; =&gt; data.Sprites.chainmailArmorSprite&#10;        case &quot;Plate Armor&quot; =&gt; data.Sprites.plateArmorSprite&#10;        case _ =&gt; data.Sprites.defaultItemSprite&#10;      }&#10;      spriteSheet.fromSprite(sprite).moveTo(armorSlotX, armorY)&#10;    }.toSeq&#10;    &#10;    // Equipment stats with better positioning&#10;    val totalDamageReduction = equipment.getTotalDamageReduction&#10;    val statsY = paperdollY + (spriteScale * 4)&#10;    val statsText = text(s&quot;Total DR: $totalDamageReduction&quot;, paperdollX + defaultBorderSize, statsY)&#10;    &#10;    Seq(background, title, helmetSlot, helmetLabel, armorSlot, armorLabel, statsText).toBatch ++ &#10;    helmetItem.toBatch ++ armorItem.toBatch&#10;  }&#10;&#10;  def perkSelection(model: GameController): Batch[SceneNode] = {&#10;    model.uiState match {&#10;      case uiState@UIState.ListSelect(list, _, _) if list.head.isInstanceOf[StatusEffect] =&gt;&#10;        val perkCardWidth = spriteScale * 4 // Width of the perk card&#10;        val perkCardHeight = spriteScale * 6 // Height of the perk card&#10;&#10;        // Get the possible perks for the player&#10;        val perks = uiState.list.asInstanceOf[Seq[StatusEffect]]&#10;&#10;        val numPerks = perks.size&#10;        val spacing = spriteScale * 2&#10;        val totalWidth = numPerks * perkCardWidth + (numPerks - 1) * spacing&#10;        val startX = (canvasWidth - totalWidth) / 2&#10;&#10;        (for {&#10;          (perk, index) &lt;- perks.zipWithIndex&#10;        } yield {&#10;          val index = perks.indexOf(perk)&#10;          val isChosenPerk: Boolean = uiState.index == index&#10;&#10;          val itemX = startX + index * (perkCardWidth + spacing)&#10;          val itemY = spriteScale * 3&#10;&#10;          // Draw the perk rectangle&#10;          Seq(&#10;            BlockBar.getBlockBar(&#10;              Rectangle(Point(itemX.toInt, itemY.toInt), Size(perkCardWidth, perkCardHeight)),&#10;              if (isChosenPerk) RGBA.Orange else RGBA.SlateGray&#10;            ),&#10;            Text(&#10;              perk.name,&#10;              itemX + defaultBorderSize,&#10;              itemY + defaultBorderSize,&#10;              PixelFont.fontKey,&#10;              Assets.assets.generated.PixelFontMaterial&#10;            ),&#10;            // Draw the perk description and wrap to fit within the card width&#10;            Text(&#10;              //Wrap the description text if full words are longer than 14 characters on a line&#10;              wrapText(perk.description, 13).mkString(&quot;\n&quot;),&#10;              itemX + defaultBorderSize,&#10;              itemY + spriteScale + defaultBorderSize,&#10;              PixelFontSmall.fontKey,&#10;              Assets.assets.generated.PixelFontSmallMaterial&#10;            )&#10;          )&#10;        }).flatten.toBatch&#10;      case _ =&gt;&#10;        Batch.empty&#10;    }&#10;  }&#10;&#10;  def enemyHealthBar(enemyEntity: Entity): Batch[SceneNode] = {&#10;    import game.entity.EntityType.*&#10;    import game.entity.Health.*&#10;    import game.entity.Movement.*&#10;&#10;    if (enemyEntity.entityType == game.entity.EntityType.Enemy) {&#10;      val game.Point(xPosition, yPosition) = enemyEntity.position&#10;      &#10;      val currentHealth = enemyEntity.currentHealth&#10;      val maxHealth = enemyEntity.maxHealth&#10;&#10;      val barWidth = spriteScale // Total width of the health bar&#10;      val barHeight = spriteScale / 5 // Height of the health bar&#10;      val xOffset = xPosition * spriteScale + uiXOffset - (spriteScale / 2) // X position of the bar&#10;      val yOffset = yPosition * spriteScale + uiYOffset + (spriteScale / 2)// Y position of the bar&#10;&#10;      val filledWidth = (currentHealth * barWidth) / maxHealth&#10;&#10;      BlockBar.attributeBar(&#10;        bounds = Rectangle(Point(xOffset, yOffset), Size(barWidth, barHeight)),&#10;        filledWidth = filledWidth,&#10;        fullColour = RGBA.Green,&#10;        emptyColour = RGBA.Crimson,&#10;        borderWidth = 1&#10;      )&#10;    } else Batch.empty&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="package indigoengine.view&#10;&#10;import game.entity.{Entity, Equipment}&#10;import game.entity.Equipment.*&#10;import game.status.StatusEffect&#10;import generated.{Assets, PixelFont, PixelFontSmall}&#10;import indigo.*&#10;import indigo.Batch.toBatch&#10;import indigoengine.SpriteExtension.*&#10;import ui.UIConfig.*&#10;import ui.{GameController, UIState}&#10;&#10;object Elements {&#10;  def text(text: String, x: Int, y: Int): SceneNode = Text(&#10;    text,&#10;    x,&#10;    y,&#10;    PixelFont.fontKey,&#10;    Assets.assets.generated.PixelFontMaterial&#10;  )&#10;&#10;  def wrapText(text: String, maxLineLength: Int): Seq[String] = {&#10;    text.split(&quot;\\s+&quot;).foldLeft(Seq(&quot;&quot;)) { (lines, word) =&gt;&#10;      val currentLine = lines.last&#10;      if (currentLine.isEmpty) lines.init :+ word&#10;      else if ((currentLine.length + 1 + word.length) &lt;= maxLineLength)&#10;        lines.init :+ (currentLine + &quot; &quot; + word)&#10;      else&#10;        lines :+ word&#10;    }&#10;  }&#10;&#10;  def healthBar(model: GameController): Batch[SceneNode] = {&#10;    import game.entity.Health.*&#10;&#10;    val currentHealth = model.gameState.playerEntity.currentHealth&#10;    val maxHealth = model.gameState.playerEntity.maxHealth&#10;&#10;    val barWidth = spriteScale * 6 // Total width of the health bar&#10;    val barHeight = (spriteScale / 4) * 3 // Height of the health bar&#10;    val xOffset = uiXOffset // X position of the bar&#10;    val yOffset = uiYOffset // Y position of the bar&#10;&#10;    val filledWidth = (currentHealth * barWidth) / maxHealth&#10;&#10;    BlockBar.attributeBar(&#10;      Rectangle(Point(xOffset, yOffset), Size(barWidth, barHeight)),&#10;      filledWidth,&#10;      RGBA.Green,&#10;      RGBA.Crimson,&#10;    ) :+ text(s&quot;$currentHealth/$maxHealth&quot;, xOffset + barWidth + defaultBorderSize, yOffset)&#10;  }&#10;  &#10;  def experienceBar(model: GameController): Batch[SceneNode] = {&#10;    import game.entity.Experience.*&#10;&#10;    val player = model.gameState.playerEntity&#10;    &#10;    val currentExp = player.experience&#10;    val nextLevelExp = player.nextLevelExperience&#10;&#10;    val drawableCurrentExperience = currentExp - player.previousLevelExperience&#10;    val drawableNextLevelExperience = nextLevelExp - player.previousLevelExperience&#10;&#10;    // Calculate the width of the filled portion of the experience bar&#10;&#10;    val barWidth = spriteScale * 6 // Total width of the experience bar&#10;    val barHeight = spriteScale / 2 // Height of the experience bar&#10;    val xOffset = uiXOffset // X position of the bar&#10;    val yOffset = uiYOffset + spriteScale // Y position of the bar&#10;&#10;    val filledWidth: Int = if (player.canLevelUp) barWidth &#10;    else (drawableCurrentExperience * barWidth) / drawableNextLevelExperience&#10;&#10;    BlockBar.attributeBar(&#10;      Rectangle(Point(xOffset, yOffset), Size(barWidth, barHeight)),&#10;      filledWidth,&#10;      RGBA.Orange,&#10;      RGBA.SlateGray,&#10;    ) ++ (if(player.canLevelUp)&#10;      Some(text(&quot;Press 'L' to level up!&quot;, xOffset + barWidth + defaultBorderSize, yOffset - defaultBorderSize))&#10;    else None).toSeq.toBatch&#10;  }&#10;&#10;  def usableItems(model: GameController, spriteSheet: Graphic[?]): Batch[SceneNode] = {&#10;    import game.entity.Inventory.*&#10;    import game.entity.{PotionItem, ScrollItem, BowItem, ArrowItem}&#10;    import data.Sprites&#10;    &#10;    val player = model.gameState.playerEntity&#10;    val usableItems = player.usableItems(model.gameState)&#10;    val allInventoryItems = player.inventoryItems(model.gameState)&#10;    &#10;    if (usableItems.isEmpty) {&#10;      Batch.empty&#10;    } else {&#10;      val startX = uiXOffset&#10;      val startY = uiYOffset + (spriteScale * 2) + defaultBorderSize // Position below experience bar&#10;      val itemSize = spriteScale&#10;      val itemSpacing = itemSize + (defaultBorderSize / 2)&#10;      &#10;      // Group items by type and count quantities&#10;      val potionCount = usableItems.count(_.has[PotionItem])&#10;      val scrollCount = usableItems.count(_.has[ScrollItem])&#10;      val bowCount = usableItems.count(_.has[BowItem])&#10;      val arrowCount = allInventoryItems.count(_.has[ArrowItem])&#10;      &#10;      // Create list of item types we have with their sprites&#10;      val itemGroups = Seq(&#10;        (potionCount, Sprites.potionSprite, &quot;potion&quot;),&#10;        (scrollCount, Sprites.scrollSprite, &quot;scroll&quot;),&#10;        (bowCount, Sprites.bowSprite, &quot;bow&quot;)&#10;      ).filter(_._1 &gt; 0) // Only show items we have&#10;      &#10;      // Display each item type with its quantity&#10;      val itemDisplays = itemGroups.zipWithIndex.flatMap { case ((count, sprite, itemType), index) =&gt;&#10;        val itemX = startX + (index * itemSpacing)&#10;        val itemY = startY&#10;        &#10;        // For bows, show arrow count; for other items, show item count&#10;        val quantity = if (itemType == &quot;bow&quot;) arrowCount else count&#10;        &#10;        Seq(&#10;          spriteSheet.fromSprite(sprite).moveTo(itemX, itemY),&#10;          text(quantity.toString, itemX + itemSize - 8, itemY + itemSize - 12)&#10;        )&#10;      }&#10;      &#10;      itemDisplays.toBatch&#10;    }&#10;  }&#10;  &#10;  def keys(model: GameController, spriteSheet: Graphic[?]): Batch[SceneNode] = {&#10;    // TODO: Reimplement keys display for new component system  &#10;    Batch.empty&#10;  }&#10;&#10;  def equipmentPaperdoll(model: GameController, spriteSheet: Graphic[?]): Batch[SceneNode] = {&#10;    import game.entity.Equipment.*&#10;&#10;    val player = model.gameState.playerEntity&#10;    val equipment = player.equipment&#10;    &#10;    // Position paperdoll on the right side of the screen with more space&#10;    val paperdollWidth = spriteScale * 4&#10;    val paperdollHeight = spriteScale * 5&#10;    val paperdollX = canvasWidth - paperdollWidth - defaultBorderSize&#10;    val paperdollY = uiYOffset&#10;    &#10;    // Create background for paperdoll&#10;    val background = BlockBar.getBlockBar(&#10;      Rectangle(Point(paperdollX - defaultBorderSize, paperdollY - defaultBorderSize), &#10;                Size(paperdollWidth + (defaultBorderSize * 2), paperdollHeight + (defaultBorderSize * 2))),&#10;      RGBA.SlateGray.withAlpha(0.3f)&#10;    )&#10;    &#10;    // Title&#10;    val title = text(&quot;Equipment&quot;, paperdollX, paperdollY - (defaultBorderSize * 3))&#10;    &#10;    // Helmet slot with better spacing&#10;    val helmetY = paperdollY + spriteScale&#10;    val helmetSlotX = paperdollX + spriteScale * 3&#10;    val helmetSlot = BlockBar.getBlockBar(&#10;      Rectangle(Point(helmetSlotX, helmetY), Size(spriteScale, spriteScale)),&#10;      RGBA.SlateGray.withAlpha(0.5f)&#10;    )&#10;    val helmetLabel = text(&quot;Helmet:&quot;, paperdollX + defaultBorderSize, helmetY + (spriteScale / 4))&#10;    &#10;    val helmetItem = equipment.helmet.map { helmet =&gt;&#10;      val sprite = helmet.itemName match {&#10;        case &quot;Leather Helmet&quot; =&gt; data.Sprites.leatherHelmetSprite&#10;        case &quot;Iron Helmet&quot; =&gt; data.Sprites.ironHelmetSprite&#10;        case _ =&gt; data.Sprites.defaultItemSprite&#10;      }&#10;      spriteSheet.fromSprite(sprite).moveTo(helmetSlotX, helmetY)&#10;    }.toSeq&#10;    &#10;    // Armor slot with better spacing  &#10;    val armorY = paperdollY + (spriteScale * 2) + defaultBorderSize&#10;    val armorSlotX = paperdollX + spriteScale * 3&#10;    val armorSlot = BlockBar.getBlockBar(&#10;      Rectangle(Point(armorSlotX, armorY), Size(spriteScale, spriteScale)),&#10;      RGBA.SlateGray.withAlpha(0.5f)&#10;    )&#10;    val armorLabel = text(&quot;Armor:&quot;, paperdollX + defaultBorderSize, armorY + (spriteScale / 4))&#10;    &#10;    val armorItem = equipment.armor.map { armor =&gt;&#10;      val sprite = armor.itemName match {&#10;        case &quot;Chainmail Armor&quot; =&gt; data.Sprites.chainmailArmorSprite&#10;        case &quot;Plate Armor&quot; =&gt; data.Sprites.plateArmorSprite&#10;        case _ =&gt; data.Sprites.defaultItemSprite&#10;      }&#10;      spriteSheet.fromSprite(sprite).moveTo(armorSlotX, armorY)&#10;    }.toSeq&#10;    &#10;    // Equipment stats with better positioning&#10;    val totalDamageReduction = equipment.getTotalDamageReduction&#10;    val statsY = paperdollY + (spriteScale * 4)&#10;    val statsText = text(s&quot;Total DR: $totalDamageReduction&quot;, paperdollX + defaultBorderSize, statsY)&#10;    &#10;    Seq(background, title, helmetSlot, helmetLabel, armorSlot, armorLabel, statsText).toBatch ++ &#10;    helmetItem.toBatch ++ armorItem.toBatch&#10;  }&#10;&#10;  def perkSelection(model: GameController): Batch[SceneNode] = {&#10;    model.uiState match {&#10;      case uiState@UIState.ListSelect(list, _, _) if list.head.isInstanceOf[StatusEffect] =&gt;&#10;        val perkCardWidth = spriteScale * 4 // Width of the perk card&#10;        val perkCardHeight = spriteScale * 6 // Height of the perk card&#10;&#10;        // Get the possible perks for the player&#10;        val perks = uiState.list.asInstanceOf[Seq[StatusEffect]]&#10;&#10;        val numPerks = perks.size&#10;        val spacing = spriteScale * 2&#10;        val totalWidth = numPerks * perkCardWidth + (numPerks - 1) * spacing&#10;        val startX = (canvasWidth - totalWidth) / 2&#10;&#10;        (for {&#10;          (perk, index) &lt;- perks.zipWithIndex&#10;        } yield {&#10;          val index = perks.indexOf(perk)&#10;          val isChosenPerk: Boolean = uiState.index == index&#10;&#10;          val itemX = startX + index * (perkCardWidth + spacing)&#10;          val itemY = spriteScale * 3&#10;&#10;          // Draw the perk rectangle&#10;          Seq(&#10;            BlockBar.getBlockBar(&#10;              Rectangle(Point(itemX.toInt, itemY.toInt), Size(perkCardWidth, perkCardHeight)),&#10;              if (isChosenPerk) RGBA.Orange else RGBA.SlateGray&#10;            ),&#10;            Text(&#10;              perk.name,&#10;              itemX + defaultBorderSize,&#10;              itemY + defaultBorderSize,&#10;              PixelFont.fontKey,&#10;              Assets.assets.generated.PixelFontMaterial&#10;            ),&#10;            // Draw the perk description and wrap to fit within the card width&#10;            Text(&#10;              //Wrap the description text if full words are longer than 14 characters on a line&#10;              wrapText(perk.description, 13).mkString(&quot;\n&quot;),&#10;              itemX + defaultBorderSize,&#10;              itemY + spriteScale + defaultBorderSize,&#10;              PixelFontSmall.fontKey,&#10;              Assets.assets.generated.PixelFontSmallMaterial&#10;            )&#10;          )&#10;        }).flatten.toBatch&#10;      case _ =&gt;&#10;        Batch.empty&#10;    }&#10;  }&#10;&#10;  def enemyHealthBar(enemyEntity: Entity): Batch[SceneNode] = {&#10;    import game.entity.EntityType.*&#10;    import game.entity.Health.*&#10;    import game.entity.Movement.*&#10;&#10;    if (enemyEntity.entityType == game.entity.EntityType.Enemy) {&#10;      val game.Point(xPosition, yPosition) = enemyEntity.position&#10;      &#10;      val currentHealth = enemyEntity.currentHealth&#10;      val maxHealth = enemyEntity.maxHealth&#10;&#10;      val barWidth = spriteScale // Total width of the health bar&#10;      val barHeight = spriteScale / 5 // Height of the health bar&#10;      val xOffset = xPosition * spriteScale + uiXOffset - (spriteScale / 2) // X position of the bar&#10;      val yOffset = yPosition * spriteScale + uiYOffset + (spriteScale / 2)// Y position of the bar&#10;&#10;      val filledWidth = (currentHealth * barWidth) / maxHealth&#10;&#10;      BlockBar.attributeBar(&#10;        bounds = Rectangle(Point(xOffset, yOffset), Size(barWidth, barHeight)),&#10;        filledWidth = filledWidth,&#10;        fullColour = RGBA.Green,&#10;        emptyColour = RGBA.Crimson,&#10;        borderWidth = 1&#10;      )&#10;    } else Batch.empty&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>